---
sidebar_position: 4
id: 04-group-theory-basics
title: Group Theory Basics (Cyclic Groups, Abelian Groups)
sidebar_label: Group Theory Basics
---

## What is a Group?

A group is a fundamental algebraic structure consisting of a set \( G \) equipped with a binary operation \( \* \) that satisfies four properties:

-   **Closure**: For every \( a, b \in G \), the result \( a \* b \in G \)
-   **Associativity**: For every \( a, b, c \in G \),  
    \[
    (a _ b) _ c = a _ (b _ c)
    \]
-   **Identity element**: There exists an element \( e \in G \) such that for every \( a \in G \),  
    \[
    e _ a = a _ e = a
    \]
-   **Inverse element**: For every \( a \in G \), there exists an element \( a^{-1} \in G \) such that  
    \[
    a _ a^{-1} = a^{-1} _ a = e
    \]

---

## What is a Cyclic Group?

A **cyclic group** is a group that can be generated by a single element \( g \), meaning every element in the group can be written as \( g^k \) for some integer \( k \).

---

## What is an Abelian Group?

An **abelian group** (or **commutative group**) is a group where the operation is commutative:

```
\[
a _ b = b _ a \quad \text{for all } a, b \in G
\]
```

---

## Why is Group Theory Important in Cryptography?

-   Many cryptographic schemes use **cyclic abelian groups** (e.g., elliptic curve groups).
-   The **discrete logarithm problem** and **Diffie-Hellman key exchange** are defined over cyclic groups.
-   Understanding group structure is key to building **secure cryptographic protocols**.

---

## Rust Implementation: Group Trait and Cyclic Group Example

```rust
/// Trait representing a Group with generic element type
pub trait Group {
    type Element: Clone + PartialEq;

    fn identity(&self) -> Self::Element;
    fn op(&self, a: &Self::Element, b: &Self::Element) -> Self::Element;
    fn inverse(&self, a: &Self::Element) -> Self::Element;
}

/// A simple cyclic group of integers modulo n (Z/nZ)
#[derive(Debug, Clone)]
pub struct CyclicGroup {
    pub modulus: u64,
}

impl Group for CyclicGroup {
    type Element = u64;

    fn identity(&self) -> Self::Element {
        0
    }

    fn op(&self, a: &Self::Element, b: &Self::Element) -> Self::Element {
        (a + b) % self.modulus
    }

    fn inverse(&self, a: &Self::Element) -> Self::Element {
        (self.modulus - a) % self.modulus
    }
}
```

### Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cyclic_group() {
        let g = CyclicGroup { modulus: 7 };

        assert_eq!(g.identity(), 0);
        assert_eq!(g.op(&3, &4), 0); // (3+4) % 7 = 0
        assert_eq!(g.inverse(&3), 4); // 7-3=4 mod 7

        // Check inverse property: a + a^{-1} = identity
        let a = 5;
        let inv_a = g.inverse(&a);
        assert_eq!(g.op(&a, &inv_a), g.identity());
    }
}
```

---

## Explanation

-   Defined a generic **Group trait** with identity, operation, and inverse.
-   Created a **concrete cyclic group** implementation: $\mathbb{Z}/n\mathbb{Z}$ with addition mod $n$.
-   Identity is `0`, operation is addition mod $n$, inverse is `n - a mod n`.
-   Tests confirm that the implementation respects group axioms.
