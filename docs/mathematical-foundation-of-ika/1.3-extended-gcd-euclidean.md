## Main theoretical foundation of the Extended Euclidean Algorithm

The Extended Euclidean Algorithm is built on a refinement of the Euclidean Algorithm:

-   Not only can we compute $\gcd(a, b)$ by repeated division with remainders,
-   we can also **track coefficients** $x, y$ such that

$$
\gcd(a, b) = ax + by
$$

This identity is known as **BÃ©zoutâ€™s Identity**.

---

### Theoretical pillars

1. **Divisibility preservation** (from Euclidean Algorithm):

    $$
    \gcd(a, b) = \gcd(b, a \bmod b)
    $$

    ensures that by recursion, the GCD can be reduced step by step.

2. **Linear combination invariance**:
   If $d$ divides both $a$ and $b$, then it divides every integer linear combination $ax + by$.
   Thus the set of all linear combinations of $a$ and $b$ is exactly the set of multiples of $\gcd(a, b)$.

3. **Back-substitution principle**:
   Every remainder in the Euclidean Algorithm can be expressed as a linear combination of $a$ and $b$.
   Working backwards from the final nonzero remainder (the GCD), we can recover explicit integers $x, y$ such that

    $$
    \gcd(a, b) = ax + by
    $$

---

### Core insight

-   The ordinary Euclidean Algorithm answers: _What is the greatest common divisor?_
-   The extended version answers: _How can that GCD be expressed as a linear combination of the original numbers?_

This is why it is foundational in number theory: it provides not only the GCD but also the constructive path to it.

---

ğŸ‘‰ So the **main theoretical foundation** of the Extended Euclidean Algorithm is **BÃ©zoutâ€™s Identity**, coupled with the fact that the Euclidean Algorithmâ€™s remainder steps preserve linear combinations.

Why is it called an identity?

Because it holds for all integers
ğ‘
,
ğ‘
a,b: their gcd can always be written as one specific linear combination. Itâ€™s a universal truth, not just a trick.

Who was BÃ©zout?

Ã‰tienne BÃ©zout (1730â€“1783) â€” a French mathematician.

Known for work on algebra and polynomial equations.

His name is attached to BÃ©zoutâ€™s Identity because he was one of the first to generalize the idea: the gcd of integers (and later polynomials) can be expressed as a linear combination of them.

ğŸ‘‰ In short: Extended Euclidean Algorithm = Euclidean Algorithm + BÃ©zoutâ€™s Identity + back-substitution.

Euclid (around 300â€¯BCE) discovered the Euclidean Algorithm: a method to compute the gcd of two numbers using repeated subtraction (or remainders).

He did not explicitly track the coefficients
ğ‘¥
x and
ğ‘¦
y for BÃ©zoutâ€™s Identity. That step â€” expressing
gcd
â¡
(
ğ‘
,
ğ‘
)
gcd(a,b) as
ğ‘
ğ‘¥

-   ğ‘
    ğ‘¦
    ax+by â€” came much later.

BÃ©zout (1730â€“1783) formalized the idea that for any integers
ğ‘
a and
ğ‘
b, there exist integers
ğ‘¥
x and
ğ‘¦
y such that

gcd
â¡
(
ğ‘
,
ğ‘
)
=
ğ‘
ğ‘¥

-   ğ‘
    ğ‘¦
    gcd(a,b)=ax+by

This is what we now call BÃ©zoutâ€™s Identity.

The Extended Euclidean Algorithm is essentially a modern algorithm that combines Euclidâ€™s method with BÃ©zoutâ€™s observation, allowing us to compute both the gcd and the coefficients
ğ‘¥
,
ğ‘¦
x,y at the same time.

So:

Euclid = gcd computation

BÃ©zout = linear combination identity

Extended Euclidean Algorithm = gcd + BÃ©zout coefficients

### Letâ€™s do a concrete example of the **Extended Euclidean Algorithm** step by step.

Weâ€™ll compute $\gcd(99, 78)$ **and** find integers $x, y$ such that:

$$
\gcd(99,78) = 99x + 78y
$$

---

### Step 1: Apply the Euclidean Algorithm (remainders)

1. $99 = 78 \cdot 1 + 21$ â†’ remainder $r_1 = 21$
2. $78 = 21 \cdot 3 + 15$ â†’ remainder $r_2 = 15$
3. $21 = 15 \cdot 1 + 6$ â†’ remainder $r_3 = 6$
4. $15 = 6 \cdot 2 + 3$ â†’ remainder $r_4 = 3$
5. $6 = 3 \cdot 2 + 0$ â†’ stop

$\gcd(99,78) = 3$

---

### Step 2: Back-substitute to find $x, y$ (BÃ©zout coefficients)

Start from the second-to-last remainder equation:

1. $3 = 15 - 6 \cdot 2$

Replace $6$ from previous equation: $6 = 21 - 15 \cdot 1$

$$
3 = 15 - (21 - 15 \cdot 1) \cdot 2 = 15 - 2 \cdot 21 + 2 \cdot 15 = 3 \cdot 15 - 2 \cdot 21
$$

Replace $15 = 78 - 21 \cdot 3$:

$$
3 = 3 \cdot (78 - 21 \cdot 3) - 2 \cdot 21 = 3 \cdot 78 - 9 \cdot 21 - 2 \cdot 21 = 3 \cdot 78 - 11 \cdot 21
$$

Replace $21 = 99 - 78 \cdot 1$:

$$
3 = 3 \cdot 78 - 11 \cdot (99 - 78) = 3 \cdot 78 - 11 \cdot 99 + 11 \cdot 78 = (3+11)\cdot 78 - 11 \cdot 99
$$

$$
\mathbf{3 = (-11) \cdot 99 + 14 \cdot 78}
$$

âœ… So one solution is $x = -11, y = 14$

---

### Step 3: Check

$$
99 \cdot (-11) + 78 \cdot 14 = -1089 + 1092 = 3
$$

Perfect!

---

So the **Extended Euclidean Algorithm** gives:

$$
\gcd(99,78) = 3, \quad x = -11, \quad y = 14
$$

The **Extended Euclidean Algorithm** is closely tied to **inverses**, both in modular arithmetic and in applications like the Chinese Remainder Theorem (CRT). Hereâ€™s how:

---

### 1ï¸âƒ£ Modular Inverse

-   Suppose you want $x$ such that

    $$
    a \cdot x \equiv 1 \pmod{m}
    $$

-   This is possible **iff $\gcd(a,m) = 1$** (i.e., $a$ and $m$ are coprime).
-   The Extended Euclidean Algorithm finds integers $x, y$ such that:

    $$
    ax + my = 1
    $$

-   Reduce modulo $m$, and you get:

    $$
    ax \equiv 1 \pmod{m}
    $$

-   So $x$ is the **modular inverse of $a$ modulo $m$**.

âœ… Thatâ€™s the main use in modular arithmetic, RSA, and cryptography.

---

### 2ï¸âƒ£ Inverse in CRT

-   In the **Chinese Remainder Theorem**, you solve systems like:

$$
x \equiv a_1 \pmod{m_1}, \quad x \equiv a_2 \pmod{m_2}, \dots
$$

-   CRT requires computing **multiplicative inverses modulo each modulus**.
-   The Extended Euclidean Algorithm gives those inverses efficiently.
-   Example: for two moduli $m_1, m_2$, you compute numbers $n_1, n_2$ such that:

    $$
    n_1 \cdot m_1 \equiv 1 \pmod{m_2}, \quad n_2 \cdot m_2 \equiv 1 \pmod{m_1}
    $$

-   These $n_1, n_2$ come directly from the Extended Euclidean Algorithm.

---

## 1ï¸âƒ£ What is an inverse?

-   In general math, the **inverse** of a number $a$ is a number $x$ that â€œundoesâ€ $a$ under some operation.

1. **Additive inverse**:

    - Undo addition: $a + x = 0$ â†’ $x = -a$

2. **Multiplicative inverse**:

    - Undo multiplication: $a \cdot x = 1$ â†’ $x = 1/a$ in real numbers

In **modular arithmetic**, we canâ€™t divide normally. Instead, a **modular inverse** of $a \mod m$ is a number $x$ such that:

$$
a \cdot x \equiv 1 \pmod{m}
$$

-   It â€œundoesâ€ multiplication modulo $m$.
-   Exists **only if $\gcd(a,m) = 1$** â€” i.e., $a$ and $m$ are coprime.

---

## 2ï¸âƒ£ How the Extended Euclidean Algorithm finds inverses

-   Recall **BÃ©zoutâ€™s Identity**:

$$
ax + my = \gcd(a,m)
$$

-   If $\gcd(a,m) = 1$, we can write:

$$
ax + my = 1
$$

-   Reduce modulo $m$: $ax \equiv 1 \pmod{m}$

-   âœ… Bingo! $x$ is the **modular inverse of $a$ modulo $m$**.

-   Thatâ€™s why the Extended Euclidean Algorithm is **the standard tool** for computing modular inverses efficiently.

---

## 3ï¸âƒ£ Why modular inverses are useful

1. **Solving modular equations**:

    - To solve $ax \equiv b \pmod{m}$, multiply both sides by $a^{-1}$:

    $$
    x \equiv b \cdot a^{-1} \pmod{m}
    $$

2. **Cryptography (RSA, ECC)**:

    - Private keys, decryption exponents, and signatures all rely on modular inverses.

3. **Chinese Remainder Theorem (CRT)**:

    - CRT solves systems like:

    $$
    x \equiv a_1 \pmod{m_1}, \quad x \equiv a_2 \pmod{m_2}, \dots
    $$

    - To combine these congruences, you need numbers that are **inverses modulo other moduli**.
    - Extended Euclidean Algorithm gives those inverses efficiently.

---

## 4ï¸âƒ£ The bigger picture

Think of it as a **chain of ideas**:

1. **Euclidean Algorithm** â†’ compute GCD efficiently.
2. **Extended Euclidean Algorithm** â†’ compute GCD **and** BÃ©zout coefficients.
3. **BÃ©zout coefficients** â†’ give **modular inverses** when gcd = 1.
4. **Modular inverses** â†’ allow:

    - Solving modular equations,
    - CRT,
    - Cryptography.

-   In other words, **everything in modular arithmetic â€œflows from the Extended Euclidean Algorithmâ€** if you need inverses.

---

### ğŸ”¹ Example: modular inverse

Find $x$ such that:

$$
7 \cdot x \equiv 1 \pmod{26}
$$

-   Compute $\gcd(7,26)$ and BÃ©zout coefficients:

    -   $26 = 7\cdot3 + 5$
    -   $7 = 5\cdot1 + 2$
    -   $5 = 2\cdot2 + 1$
    -   $2 = 1\cdot2 + 0$ â†’ gcd = 1

-   Back-substitute BÃ©zout coefficients â†’ $1 = 15\cdot7 - 4\cdot26$

-   Reduce modulo 26: $7 \cdot 15 \equiv 1 \pmod{26}$

âœ… Modular inverse of 7 modulo 26 is 15
